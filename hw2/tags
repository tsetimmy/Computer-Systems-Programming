!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BSIZE	driver_cpe.c	38;"	d	file:
C1024	config.h	32;"	d
C128	config.h	29;"	d
C2048	config.h	33;"	d
C256	config.h	30;"	d
C4096	config.h	34;"	d
C512	config.h	31;"	d
C64	config.h	28;"	d
C8192	config.h	35;"	d
CACHE_BLOCK	fcyc.c	15;"	d	file:
CACHE_BYTES	fcyc.c	14;"	d	file:
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -O2 $/;"	m
CLEAR_CACHE	fcyc.c	13;"	d	file:
COMPENSATE	fcyc.c	12;"	d	file:
DIM_CNT	driver_cpe.c	35;"	d	file:
DRIVER_CPE_OBJS	Makefile	/^DRIVER_CPE_OBJS = driver_cpe.o kernels.o fcyc.o clock.o $/;"	m
EPSILON	fcyc.c	11;"	d	file:
IS_ALPHA	clock.c	13;"	d	file:
IS_ALPHA	clock.c	15;"	d	file:
IS_x86	clock.c	20;"	d	file:
IS_x86	clock.c	22;"	d	file:
IS_x86	clock.c	24;"	d	file:
K	fcyc.c	9;"	d	file:
KEEP_SAMPLES	fcyc.c	31;"	d	file:
KEEP_VALS	fcyc.c	30;"	d	file:
LIBS	Makefile	/^LIBS = -lm$/;"	m
MAXSAMPLES	fcyc.c	10;"	d	file:
MAX_BENCHMARKS	driver_cpe.c	34;"	d	file:
MAX_DIM	driver_cpe.c	40;"	d	file:
NEVENT	clock.c	170;"	d	file:
ODD_DIM	driver_cpe.c	41;"	d	file:
R1024	config.h	17;"	d
R128	config.h	14;"	d
R2048	config.h	18;"	d
R256	config.h	15;"	d
R4096	config.h	19;"	d
R512	config.h	16;"	d
R64	config.h	13;"	d
R8192	config.h	20;"	d
RECORDTHRESH	clock.c	172;"	d	file:
RIDX	defs.h	11;"	d
THRESHOLD	clock.c	171;"	d	file:
_CONFIG_H_	config.h	5;"	d
_DEFS_H_	defs.h	7;"	d
access_counter	clock.c	/^void access_counter(unsigned *hi, unsigned *lo)$/;"	f
add_rotate_function	driver_cpe.c	/^void add_rotate_function(lab_test_func f, char *description) $/;"	f
add_sample	fcyc.c	/^static void add_sample(double val)$/;"	f	file:
bench_t	driver_cpe.c	/^} bench_t;$/;"	t	typeref:struct:__anon3	file:
benchmarks_rotate	driver_cpe.c	/^static bench_t benchmarks_rotate[MAX_BENCHMARKS];$/;"	v	file:
blue	defs.h	/^   unsigned short blue;$/;"	m	struct:__anon2
cache_block	fcyc.c	/^static int cache_block = CACHE_BLOCK;$/;"	v	file:
cache_buf	fcyc.c	/^static int *cache_buf = NULL;$/;"	v	file:
cache_bytes	fcyc.c	/^static int cache_bytes = CACHE_BYTES;$/;"	v	file:
callibrate	clock.c	/^static void callibrate(int verbose)$/;"	f	file:
check_orig	driver_cpe.c	/^static int check_orig(int dim) $/;"	f	file:
check_rotate	driver_cpe.c	/^static int check_rotate(int dim) $/;"	f	file:
clear	fcyc.c	/^static void clear()$/;"	f	file:
clear_cache	fcyc.c	/^static int clear_cache = CLEAR_CACHE;$/;"	v	file:
compare_pixels	driver_cpe.c	/^static int compare_pixels(pixel p1, pixel p2) $/;"	f	file:
compensate	fcyc.c	/^static int compensate = COMPENSATE;$/;"	v	file:
copy_of_orig	driver_cpe.c	/^static pixel *copy_of_orig = NULL; \/* copy of original for checking result *\/$/;"	v	file:
counter	clock.c	/^static unsigned int (*counter)(void)= (void *)counterRoutine;$/;"	v	file:
counterRoutine	clock.c	/^static unsigned int counterRoutine[] =$/;"	v	file:
cpes	driver_cpe.c	/^    double cpes[DIM_CNT]; \/* One CPE result for each dimension *\/$/;"	m	struct:__anon3	file:
create	driver_cpe.c	/^static void create(int dim)$/;"	f	file:
cyc_hi	clock.c	/^static unsigned cyc_hi = 0;$/;"	v	file:
cyc_lo	clock.c	/^static unsigned cyc_lo = 0;$/;"	v	file:
cyc_per_tick	clock.c	/^static double cyc_per_tick = 0.0;$/;"	v	file:
data	driver_cpe.c	/^static pixel data[(3*MAX_DIM*MAX_DIM) + (BSIZE\/sizeof(pixel))];$/;"	v	file:
description	driver_cpe.c	/^    char *description;    \/* ASCII description of the test function *\/$/;"	m	struct:__anon3	file:
email1	defs.h	/^  char *name1, *email1;$/;"	m	struct:__anon1
email2	defs.h	/^  char *name2, *email2;$/;"	m	struct:__anon1
epsilon	fcyc.c	/^static double epsilon = EPSILON;$/;"	v	file:
fcyc	fcyc.c	/^double fcyc(test_funct f, int *params)$/;"	f
fcyc_v	fcyc.c	/^double fcyc_v(test_funct_v f, void *params[])$/;"	f
func_wrapper	driver_cpe.c	/^void func_wrapper(void *arglist[]) $/;"	f
get_comp_counter	clock.c	/^double get_comp_counter() $/;"	f
get_counter	clock.c	/^double get_counter()$/;"	f
green	defs.h	/^   unsigned short green;$/;"	m	struct:__anon2
has_converged	fcyc.c	/^static int has_converged()$/;"	f	file:
init_sampler	fcyc.c	/^static void init_sampler()$/;"	f	file:
kbest	fcyc.c	/^static int kbest = K;$/;"	v	file:
lab_test_func	defs.h	/^typedef void (*lab_test_func) (int, pixel*, pixel*);$/;"	t
main	driver_cpe.c	/^int main(int argc, char *argv[])$/;"	f
max	driver_cpe.c	45;"	d	file:
maxsamples	fcyc.c	/^static int maxsamples = MAXSAMPLES;$/;"	v	file:
mhz	clock.c	/^double mhz(int verbose)$/;"	f
mhz_full	clock.c	/^double mhz_full(int verbose, int sleeptime)$/;"	f
min	driver_cpe.c	44;"	d	file:
naive_rotate	kernels.c	/^void naive_rotate(int dim, pixel *src, pixel *dst) $/;"	f
naive_rotate_descr	kernels.c	/^char naive_rotate_descr[] = "naive_rotate: Naive baseline implementation";$/;"	v
name1	defs.h	/^  char *name1, *email1;$/;"	m	struct:__anon1
name2	defs.h	/^  char *name2, *email2;$/;"	m	struct:__anon1
orig	driver_cpe.c	/^static pixel *orig = NULL;         \/* original image *\/$/;"	v	file:
ovhd	clock.c	/^double ovhd()$/;"	f
pixel	defs.h	/^} pixel;$/;"	t	typeref:struct:__anon2
random_in_interval	driver_cpe.c	/^static int random_in_interval(int low, int high) $/;"	f	file:
red	defs.h	/^   unsigned short red;$/;"	m	struct:__anon2
register_rotate_functions	kernels.c	/^void register_rotate_functions() $/;"	f
result	driver_cpe.c	/^static pixel *result = NULL;       \/* result image *\/$/;"	v	file:
rotate	kernels.c	/^void rotate(int dim, pixel *src, pixel *dst) $/;"	f
rotate_baseline_cpes	driver_cpe.c	/^static double rotate_baseline_cpes[] = {R64, R128, R256, R512, R1024, R2048,R4096,R8192};$/;"	v	file:
rotate_benchmark_count	driver_cpe.c	/^static int rotate_benchmark_count = 0;$/;"	v	file:
rotate_descr	kernels.c	/^char rotate_descr[] = "rotate: Current working version";$/;"	v
rotate_maxmean	driver_cpe.c	/^double rotate_maxmean = 0.0;$/;"	v
rotate_maxmean_desc	driver_cpe.c	/^char *rotate_maxmean_desc = NULL;$/;"	v
run_rotate_benchmark	driver_cpe.c	/^void run_rotate_benchmark(int idx, int dim) $/;"	f
samplecount	fcyc.c	/^static int samplecount = 0;$/;"	v	file:
samples	fcyc.c	/^static double *samples = NULL;$/;"	v	file:
set_fcyc_cache_block	fcyc.c	/^void set_fcyc_cache_block(int bytes) {$/;"	f
set_fcyc_cache_size	fcyc.c	/^void set_fcyc_cache_size(int bytes)$/;"	f
set_fcyc_clear_cache	fcyc.c	/^void set_fcyc_clear_cache(int clear)$/;"	f
set_fcyc_compensate	fcyc.c	/^void set_fcyc_compensate(int compensate_arg)$/;"	f
set_fcyc_epsilon	fcyc.c	/^void set_fcyc_epsilon(double epsilon_arg)$/;"	f
set_fcyc_k	fcyc.c	/^void set_fcyc_k(int k)$/;"	f
set_fcyc_maxsamples	fcyc.c	/^void set_fcyc_maxsamples(int maxsamples_arg)$/;"	f
sink	fcyc.c	/^static volatile int sink = 0;$/;"	v	file:
start_comp_counter	clock.c	/^void start_comp_counter() $/;"	f
start_counter	clock.c	/^void start_counter()$/;"	f
start_tick	clock.c	/^static clock_t start_tick = 0;$/;"	v	file:
team	defs.h	/^  char *team;$/;"	m	struct:__anon1
team	kernels.c	/^team_t team = {$/;"	v
team_t	defs.h	/^} team_t;$/;"	t	typeref:struct:__anon1
test_dim_rotate	driver_cpe.c	/^static int test_dim_rotate[] = {64, 128, 256, 512, 1024,2048,4096};$/;"	v	file:
test_funct	fcyc.h	/^typedef void (*test_funct)(int *);$/;"	t
test_funct_v	fcyc.h	/^typedef void (*test_funct_v)(void *);$/;"	t
test_rotate	driver_cpe.c	/^void test_rotate(int bench_index) $/;"	f
tfunct	driver_cpe.c	/^    lab_test_func tfunct; \/* The test function *\/$/;"	m	struct:__anon3	file:
usage	driver_cpe.c	/^void usage(char *progname) $/;"	f
valid	driver_cpe.c	/^    unsigned short valid; \/* The function is tested if this is non zero *\/$/;"	m	struct:__anon3	file:
values	fcyc.c	/^static double *values = NULL;$/;"	v	file:
